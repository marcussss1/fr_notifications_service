# Сервис уведомлений

## Архитектура проекта

### `/db`

Содержит файл, инициализирующий БД при запуске.

### `/docs`

Содержит API в формате SWAGGER.

### `/internal/middleware`

Содержит миддлварю логирующую все запросы.

### `/internal/services`

Содержит ручки, логически разбитые по сущностям(клиенты, сообщения, рассылки), сущности написаны при помощи чистой архитектуры.

### `/monitoring/prometheus`

Содержит конфиг прометеуса.

## Запуск

Для запуска контейнеров
```shell
make run
```

Для остановка контейнеров
```shell
make stop
```

## Логика рассылки

В БД лежат две таблицы:
```
CREATE TABLE IF NOT EXISTS mailing (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT (now() at time zone 'UTC'),
    text VARCHAR(1000),
    filter VARCHAR(100),
    finished_at TIMESTAMP WITH TIME ZONE DEFAULT (now() at time zone 'UTC')
);

CREATE TABLE IF NOT EXISTS pending_mailing (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    mailing_id UUID,
    status INTEGER
);
```

mailing отвечает за сущность рассылки, в pending_mailing мы добавляем id рассылок, которые нужно будет запустить позже, status показывает запущена ли эта рассылка в данный момент(PENDING_MAILING_STATUS_IN_WORK = 2) или ее следует запустить позже(PENDING_MAILING_STATUS_CREATED = 1).

При создании рассылки есть два исхода:
1) Приходит запрос, при котором время создания ссылки < текущего времени, тогда мы создаем запись в mailing и в горутине запускаем рассылку(internal/pkg/services/messages/usecase.StartMailing), клиенту отдаем запись из БД.

   StartMailing - отвечает за рассылку сообщений клиентам, смотрит filter по какому полю нужно сделать выборку(mobile_operator_code или tag) и достает клиентов, далее пробегаемся в цикле по клиентам и создаем горутину, в которой:

   Создаем сущность сообщения в базе со статусом MESSAGE_STATUS_CREATED(также есть еще два статуса MESSAGE_STATUS_SUCCEEDED, MESSAGE_STATUS_FAILED), если удалось создать сообщения, то увеличиваем счетчик прометеуса по количеству сообщений, далее идем в функцию internal/pkg/services/messages/usecase.sendMessageToThirdService, у нее следующая логика:

   Она ходит в сторонний сервис, исходя из бизнес-требований можно по разному реализовать эту логику, я решил реализовать через github.com/avast/retry-go, мы три раза пытаемся сходить в сервис, со следующим интервалом: 1, 2, 4 секунды, также во время нашего похода может истечь время рассылки, и если она истекла, то мы прекращаем поход.

   Получив ответ от стороннего сервиса:
    1) Успешно: обновляем статус сообщения на MESSAGE_STATUS_SUCCEEDED и увеличиваем счетчик прометеуса по количеству успешных сообщений.

    2) Провал: обновляем статус сообщения на MESSAGE_STATUS_FAILED и увеличиваем счетчик прометеуса по количеству проваленных сообщений.

2) Приходит запрос, который нужно запустить позже, мы создаем запись в mailing и pending_mailing кладем id рассылки, со статусом PENDING_MAILING_STATUS_CREATED, отдаем клиенту рассылку.

   В отдельной горутине работает воркер(internal/pkg/services/pending_mailing/usecase.PendingMailingWatchdog), который отвечает за обработку отложенных рассылок. Раз в секунду он ходит в БД и достает записи из pending_mailing, время, которых настало(created_at < текущего времени) и со статусом PENDING_MAILING_STATUS_CREATED.

   Далее пробегается по полученным рассылкам и в горутине делает следующее: переводит рассылку из pending_mailing в статус PENDING_MAILING_STATUS_IN_WORK(для того, чтобы через секунду воркер не взял из БД), запускает internal/pkg/services/messages/usecase.StartMailing и удаляет информацию об отложенной рассылке из pending_mailing.

## Дополнительные задания

1. Я очень люблю и уважаю unit тесты, в любой качественной разработке без них никуда, но здесь их, к сожалению, нет.

2. Накидал простенький .gitlab-ci.yml

3. docker-compose.yml поднимает сервис, постгрю и прометеус.

4. localhost:8083/api/v1/docs - открывается API спецификация.

5. Притащил прометеус, который снимает: счетчик активных горутин, счетчик общего количество сообщений, счетчик не доставленных сообщений, счетчик доставленных сообщений.

6. Логирую все http запросы и ошибки.
